---
title: "Setting Up Shaders with React Three Fiber"
date: 2021-05-01
author: Tom
slug: react-three-fiber-shaders-setup
---

This post covers the necessary iterations on the CRA template to get working
with shaders with [React Three Fiber](https://docs.pmnd.rs/react-three-fiber),
including animation and gestures with
[React Spring](https://docs.pmnd.rs/react-spring) and
[Use Gesture](http://use-gesture.netlify.app/docs).

TLDR template repo @ https://github.com/mysterybear/r3f-react-app

# 1. GLSL in a React App

`yarn add raw-loader glslify-loader glslify` and add this to
`webpack.config.js`:

```js
{
  test: /\.(glsl|frag|vert)$/,
  use: [
    require.resolve("raw-loader"),
    require.resolve("glslify-loader"),
  ],
}
```

Add to `src/react-app-env.d.ts`:

```js
declare module "*.glsl" {
  const src: string
  export default src
}

declare module "glslify"
```

You can now import GLSL files as strings and you can use GLSL modules with
[glslify](https://github.com/glslify/glslify) e.g.:

```ts
import rawFragmentShader from "./fragment.glsl"
import glsl from "glslify"

const fragmentShader = glsl(rawFragmentShader)
```

# 2. GLSL with Three.js via React Three Fiber

`yarn add @react-three/fiber three @types/three @react-three/drei`

Three.js vertex shaders be like:

```cpp
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
```

(from https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram)

Here's a "hello, world" fragment shader, using the
[`glsl-earth`](https://github.com/mattdesl/glsl-earth) module
(`yarn add glsl-earth`):

```cpp
#ifdef GL_ES
precision mediump float;
#endif

varying vec2 vUv;
uniform vec2 u_offset;
uniform float u_time;

// clang-format off
#pragma glslify: planet = require('glsl-earth')
// clang-format on

void main() {
  vec2 resolution = vec2(640, 640);
  float size = 0.75;
  vec2 rot = vec2(u_time * 0.03 + u_offset.x, u_time * 0.01 + u_offset.y);

  vec3 color = planet(vUv, resolution, size, rot);

  gl_FragColor.rgb = color;
  gl_FragColor.a = 1.0;
}
```

And here's our material:

```ts
import { shaderMaterial } from "@react-three/drei"
import { extend } from "@react-three/fiber"
import * as THREE from "three"
import fragmentShader from "../shaders/fragment.glsl"
import vertexShader from "../shaders/vertex.glsl"
import glsl from "glslify"

export const BasicShaderMaterial = shaderMaterial(
  {
    u_time: 0,
    u_offset: new THREE.Vector2(),
  },
  glsl(vertexShader),
  glsl(fragmentShader)
)

export type BasicShaderMaterialImpl = {
  u_time?: { value: number }
  u_offset?: { value: THREE.Vector2 }
} & JSX.IntrinsicElements["shaderMaterial"]

extend({ BasicShaderMaterial })

declare global {
  namespace JSX {
    interface IntrinsicElements {
      basicShaderMaterial: BasicShaderMaterialImpl
    }
  }
}
```

And our App:

```tsx
import "../materials/BasicShaderMaterial"

const App = () => {
  return (
    <mesh>
      <planeBufferGeometry args={[4, 4]} />
      <basicShaderMaterial />
    </mesh>
  )
}

export default App
```

Voila, hello static earth

# 3. Bells and Whistles (Animation, Gestures)

Let's animate using `@react-spring/three` _and_ mutating a ref in R3F's
`useFrame` at the same time, hooked up to `@use-gesture/react`'s gestures.

`yarn add @react-spring/three @use-gesture/react` for deps.

Add this to material to make it spring:

```ts
import { animated } from "@react-spring/three"

// ...

export const AnimatedBasicShaderMaterial = animated(
  forwardRef<BasicShaderMaterialImpl, any>((props, ref) => (
    <basicShaderMaterial ref={ref} {...props} />
  ))
)
```

Now here's our App:

```tsx
import { useSpring } from "@react-spring/three"
import { useFrame, useThree } from "@react-three/fiber"
import { useDrag } from "@use-gesture/react"
import { useRef } from "react"
import "../materials/BasicShaderMaterial"
import {
  AnimatedBasicShaderMaterial,
  BasicShaderMaterialImpl,
} from "../materials/BasicShaderMaterial"

const App = () => {
  const ref = useRef<BasicShaderMaterialImpl>(null)

  const [{ offset }, spring] = useSpring(() => ({
    offset: [0, 0],
    immediate: true,
  }))

  const factor = useThree(three => three.viewport.factor)

  const bind = useDrag(
    ({ offset }) => {
      spring.start({ offset })
    },
    { transform: ([x, y]) => [x / factor, -y / factor] }
  )

  useFrame(({ clock }) => {
    const material = ref.current
    if (!material) return
    if (material.uniforms?.u_time) {
      material.uniforms.u_time.value = clock.getElapsedTime()
    }
  })

  return (
    <mesh {...(bind() as any)}>
      <planeBufferGeometry args={[4, 4]} />
      <AnimatedBasicShaderMaterial ref={ref} uniforms-u_offset-value={offset} />
    </mesh>
  )
}

export default App
```

<iframe src="https://codesandbox.io/embed/github/mysterybear/r3f-react-app" />

We're animating with `useFrame` and with a `ref` at the same time, on a
`ShaderMaterial`! How wonderful
